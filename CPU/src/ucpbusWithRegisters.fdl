ipblock circularArrayBus(in address : ns(32);
                      in wr,rd : ns(1);
                      in idata : tc(32);
	              out odata : tc(32))
{
	iptype "ram";
	ipparm "size=32";
	ipparm "wl=32";
}

dp mwiFilterBus(	 in datain : tc(32);
			 in datainrdy : ns(1);
			 out dataout : tc(32);
			 out dataoutrdy : ns(1);
			 in stall : ns(1))
{
	//Input registers
	reg datainReg : tc(32);
	reg hasDataIn : ns (1); //Corresponds to datainrdyReg
	reg dataoutReg : tc(32); //Added(*)
	reg stallReg : ns(1);
	//reg dataoutrdyReg : ns(1); Not needed as stall==0 and stallReg==0 takes almost no time, which is what sets dataoutrdy

	//Registers for normal usage.
	reg difference : tc(32);
	reg formerValue : tc(32);
	reg arrayIndex : ns(5);
	reg sum : tc(32);

	sig datainRegSig : tc(32);
	sig circArrayOut : tc(32);
	sig indexPP : ns(5);	
	sig writeCircularArray : ns(1);
	sig readCircularArray : ns(1);
	sig updatedSum : tc(32);
	use circularArrayBus(indexPP,writeCircularArray,readCircularArray, datainReg, circArrayOut);

	sfg stall{ //Though it stalls, it calculates the values for cycle 1.
		hasDataIn = datainrdy; //(*) Check here - if datainrdy is on for a long time, will it not run more than one time in a row?
		datainReg = datain;
		dataoutrdy = 0;
		dataoutReg = 0;
		dataout = 0;
		stallReg = stall;

		writeCircularArray = 1;
		readCircularArray = 0;
		indexPP = arrayIndex;
	}
	sfg awaitNoStall{
		difference = datainReg - formerValue;
		writeCircularArray = 1;
		readCircularArray = 0;
		indexPP = arrayIndex;
		dataoutrdy = 0;
		dataoutReg = 0;
		dataout = dataoutReg;
		stallReg = 0; //Important as addSumShift else will give dataoutrdy = 1 before dataout=dataoutReg
	}
	sfg addSumShift{
		updatedSum = sum + difference;
		sum = updatedSum;
		dataoutReg = (tc(32))updatedSum[5:31];
		dataout = dataoutReg;
		stallReg = stall;
		dataoutrdy = 0;
		indexPP = arrayIndex + 1;
		arrayIndex = indexPP;		
		writeCircularArray = 0;
		readCircularArray = 1;
	}
	sfg awaithandshake{
		dataoutrdy = (stall == 0);
		dataout = dataoutReg;
		stallReg = stall;

		//circularArrayBus needs to get it's inputs
		indexPP = arrayIndex;
		writeCircularArray = 0;
		readCircularArray = 0;
	}
	sfg getRedyToNextValue{
		formerValue = circArrayOut;
		writeCircularArray = 0;
		readCircularArray = 0;
		indexPP = arrayIndex;
		hasDataIn = 0;		
		dataoutrdy = 0;
		dataout = dataoutReg; //(*)Is fixed but needs to be done two times in a row.
		dataoutReg = dataoutReg;
		stallReg = stall;
	}
	always
	{			
		$display($dec, "Cycle = ", $cycle);
		$display($dec, "In UCP, datain = ", datain, ", datainrdy = ", datainrdy, ", dataout = ", dataout, ", dataoutrdy = ", dataoutrdy, ", stall = ", stall);
		$display($dec, "Also in UCP, hasDataIn = ", hasDataIn, ", difference = ", difference, ", sum = ", sum, ", arrayindex = ", arrayIndex);
	}
}

fsm ucpBus(mwiFilterBus){
	initial sStall;
	state sCycle2,sCycle3;
	
	@sStall  if(hasDataIn)     then 		(awaitNoStall) 		-> sCycle2;
		 else				    	(stall)        		-> sStall;
	@sCycle2 		         		(addSumShift)		-> sCycle3;
	@sCycle3 if(stallReg == 1) then			(awaithandshake)	-> sCycle3;					
		 else 					(getRedyToNextValue) 	-> sStall; //And ready for the next round.
}














