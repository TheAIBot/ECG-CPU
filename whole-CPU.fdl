dp ALU(in a, b : ns(32); 
	   in select : ns(2); 
	   out ALUout : ns(32)) {
	always {
		ALUout = select == 0b00 ? a +  b :
			 select == 0b01 ? a -  b :
			 select == 0b10 ? a >> b :
				 	  a &  b;
		$display($dec, "alu = ", ALUout);
	}
}


dp testALU(out a, b:tc(32); out select : ns(2); in ALUout:tc(32)) {
	always{$display($dec, "Cycle:", $cycle, "Testing advanced ALU for the CPU. a = ", a , ", b = ", b , " select = ", select, ", ALUout = ", ALUout);}
	sfg test_ADD { a=535; b=35; select = 0b00;}
	sfg test_SUB { a=535; b=35; select = 0b01;}
	sfg test_SHIFT_RIGHT { a=535; b=3; select = 0b10;}
	sfg test_AND { a=0b1101011; b=0b1111; select = 0b11;}
}

// state machine to control testbench
fsm f_testbench(testALU){
	initial sADD;
	state sSUB, sSHIFT_RIGHT, sAND;
	@sADD (test_ADD) -> sSUB; 
	@sSUB (test_SUB) -> sSHIFT_RIGHT;
	@sSHIFT_RIGHT (test_SHIFT_RIGHT) -> sAND;
	@sAND (test_AND) -> sADD;
}

//system myFirstSystem {
//	ALU(a,b,select,ALUout);
//	testALU(a,b,select, ALUout);
//}
dp decoder(in op : ns(3);
   	   out pcJMP : ns(1);
	   out ALUInstruction  : ns(2);
	   out useIntermediate : ns(1);
	   out storeALU : ns(1)){
	sig x : ns(5);
	always{
		x =	(op == 0b000) ? 0b00001 : 
		    (op == 0b001) ? 0b01101 : 
			(op == 0b010) ? 0b00101 :
			(op == 0b011) ? 0b00011 :
			(op == 0b100) ? 0b01011 :
			(op == 0b101) ? 0b00000 :
			(op == 0b110) ? 0b00000 :
							0b10000;
		pcJMP = x[4];
		ALUInstruction = x[2:3];
		useIntermediate = x[1];
		storeALU = x[0];
	}
}

dp testDecoder(out op : ns(3);
   	       in pcJMP : ns(1);
	       in ALUInstruction  : ns(2);
	       in useIntermediate : ns(1);
	       in storeALU : ns(1)) {
	always{$display($bin, "Cycle:", $cycle, ". Testing decoder for the CPU. op = ", op , ", pcJMP = ", pcJMP , " ALUInstruction = ", ALUInstruction, ", useIntermediate = ", useIntermediate, ", storeALU = ", storeALU);}
	sfg test_ADD	      		{ op = 0b000;}
	sfg test_AND 			{ op = 0b001;}
	sfg test_SUB 			{ op = 0b010;}
	sfg test_ADDI			{ op = 0b011;}
	sfg test_SHIFT_RIGHT_I 		{ op = 0b100;}
	sfg test_LOAD			{ op = 0b101;}
	sfg test_STORE			{ op = 0b110;}
	sfg test_JMP			{ op = 0b111;}
}

// state machine to control testbench
fsm f_testbench(testDecoder){
	initial sADD;
	state sAND, sSUB, sADDI, sSHIFT_RIGHT_I, sLOAD, sSTORE, sJMP;
	@sADD 	    	 (test_ADD)		 -> sAND;
	@sAND 		 (test_AND) 		 -> sSUB;
	@sSUB 		 (test_SUB) 		 -> sADDI;
	@sADDI 		 (test_ADDI) 		 -> sSHIFT_RIGHT_I;
	@sSHIFT_RIGHT_I	 (test_SHIFT_RIGHT_I) 	 -> sLOAD;
	@sLOAD 		 (test_LOAD) 		 -> sSTORE;
	@sSTORE	 	 (test_STORE) 		 -> sJMP;
	@sJMP 		 (test_JMP) 		 -> sADD;
}

//system myFirstSystem {
//	decoder(op, pcJMP, ALUInstruction, useIntermediate, storeALU);
//	testDecoder(op, pcJMP, ALUInstruction, useIntermediate, storeALU);
//}
ipblock instmem(in address : ns(5);
	in wr,rd : ns(1);
	in idata : ns(32);
	out odata : ns(32))
{
	iptype "ram";
	ipparm "size=64";
	ipparm "wl=32";
	ipparm "file=UCI_programs/program.asm";
}

dp PC(in JMP : ns(26);
	  in doJMP : ns(1);
	  out pc_out : ns(32))
{
	reg b : ns(32);
	always{
		b = pc_out;
		pc_out = doJMP ? (ns(32))JMP : b + 1;
	}
}


dp fetch(in address : ns(5); out odata : ns(32))
{
	reg idata : ns(32);
	
	use instmem(address, 0, 1, idata, odata);
}
dp mux_ALU_b(in b : ns(32);
	     in intermediate : ns(23);
	     in useIntermediate : ns(1);
	     out correctB : ns(32)){
	always	{
		correctB = useIntermediate ? (ns(32))intermediate : b;
	}
}

dp testMux(out b : ns(32);
   	   out intermediate : ns(23);
	   out useIntermediate : ns(1);
	   in correctB : ns(32)){

	
	always{$display($dec, "Cycle:", $cycle, ". Testing advanced ALU mux for the CPU. b = ", b , ", intermediate = ", intermediate , " useIntermediate = ", useIntermediate, ", correctB = ", correctB);}
	sfg test_UseIntermediate {b = 55; intermediate = 35; useIntermediate = 1;}
	sfg test_UseBGiven {b = 55; intermediate = 35; useIntermediate = 0;}
}


fsm mux_testbench(testMux){
    initial sUseIntermediate;
    state sUseBGiven;
    @sUseIntermediate (test_UseIntermediate) -> sUseBGiven;
    @sUseBGiven (test_UseBGiven) -> sUseIntermediate;
}

//system myFirstSystem {
//	mux_ALU_b(b, intermediate, useIntermediate, correctB);
//	testMux(b, intermediate, useIntermediate, correctB);
//}
dp register(in asel, bsel : ns(3); 
			in storeenable : ns(1);
			in storesel : ns(3);
			in storedata : ns(32);
			out a, b : ns(32)) {
	reg r0 : ns(32);
	reg r1 : ns(32);
	reg r2 : ns(32);
	reg r3 : ns(32);
	reg r4 : ns(32);
	reg r5 : ns(32);
	reg r6 : ns(32);
	reg r7 : ns(32);

	always {
		a = asel == 0b000 ? r0 : 
			asel == 0b001 ? r1 : 
			asel == 0b010 ? r2 : 
			asel == 0b011 ? r3 : 
			asel == 0b100 ? r4 : 
			asel == 0b101 ? r5 : 
			asel == 0b110 ? r6 : 
						  r7;

		b = bsel == 0b000 ? r0 : 
			bsel == 0b001 ? r1 : 
			bsel == 0b010 ? r2 : 
			bsel == 0b011 ? r3 : 
			bsel == 0b100 ? r4 : 
			bsel == 0b101 ? r5 : 
			bsel == 0b110 ? r6 : 
						  r7;

		r1 = storeenable == 0 ?  r1 : storesel == 0b001 ?  storedata : r1;
		r2 = storeenable == 0 ?  r2 : storesel == 0b010 ?  storedata : r2;
		r3 = storeenable == 0 ?  r3 : storesel == 0b011 ?  storedata : r3;
		r4 = storeenable == 0 ?  r4 : storesel == 0b100 ?  storedata : r4;
		r5 = storeenable == 0 ?  r5 : storesel == 0b101 ?  storedata : r5;
		r6 = storeenable == 0 ?  r6 : storesel == 0b110 ?  storedata : r6;
		r7 = storeenable == 0 ?  r7 : storesel == 0b111 ?  storedata : r7;
	}
}
system CPU
{
	PC(odata[0:25], pcJMP, pc_out);
	fetch(pc_out, odata);

	decoder(odata[29:31], pcJMP, ALUInstruction, useIntermediate, storeALU);

	register(odata[23:25], odata[20:22], storeALU, odata[26:28], ALUout, a, b);
	mux_ALU_b(b, odata[0:22], useIntermediate, correctB);
	ALU(a, correctB, ALUInstruction, ALUout);
}
