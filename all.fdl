# 1 "CPU/Platform.fdl"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "/usr/include/stdc-predef.h" 1 3 4
# 1 "<command-line>" 2
# 1 "CPU/Platform.fdl"
# 1 "CPU/advanced_alu.fdl" 1
dp ALU(in a, b : ns(32);
    in select : ns(2);
    out ALUout : ns(32)) {
 always {
  ALUout = select == 0b00 ? a + b :
        select == 0b01 ? a - b :
        select == 0b10 ? a >> b :
                    a & b;

 }
}


dp testALU(out a, b:tc(32); out select : ns(2); in ALUout:tc(32)) {
 always{$display($dec, "Cycle:", $cycle, "Testing advanced ALU for the CPU. a = ", a , ", b = ", b , " select = ", select, ", ALUout = ", ALUout);}
 sfg test_ADD { a=535; b=35; select = 0b00;}
 sfg test_SUB { a=535; b=35; select = 0b01;}
 sfg test_SHIFT_RIGHT { a=535; b=3; select = 0b10;}
 sfg test_AND { a=0b1101011; b=0b1111; select = 0b11;}
}


fsm f_testbench(testALU){
 initial sADD;
 state sSUB, sSHIFT_RIGHT, sAND;
 @sADD (test_ADD) -> sSUB;
 @sSUB (test_SUB) -> sSHIFT_RIGHT;
 @sSHIFT_RIGHT (test_SHIFT_RIGHT) -> sAND;
 @sAND (test_AND) -> sADD;
}
# 2 "CPU/Platform.fdl" 2
# 1 "CPU/decoder.fdl" 1
dp decoder(in op : ns(3);
       out pcJMP : ns(1);
    out ALUInstruction : ns(2);
    out useIntermediate : ns(1);
    out storeALU : ns(1);
    out doBus : ns(1);
    out RW : ns(1)){
 sig x : ns(7);
    lookup q : ns(7) =
 {
  0b0000001,
  0b0001101,
  0b0000101,
  0b0000011,
  0b0001011,
  0b1100000,
  0b1000001,
  0b0010000
 };

 always{
        x = q(op);

  doBus = x[6];
  RW = x[5];
  pcJMP = x[4];
  ALUInstruction = x[2:3];
  useIntermediate = x[1];
  storeALU = x[0];

 }
}

dp testDecoder(out op : ns(3);
           in pcJMP : ns(1);
        in ALUInstruction : ns(2);
        in useIntermediate : ns(1);
        in storeALU : ns(1)) {
 always{$display($bin, "Cycle:", $cycle, ". Testing decoder for the CPU. op = ", op , ", pcJMP = ", pcJMP , " ALUInstruction = ", ALUInstruction, ", useIntermediate = ", useIntermediate, ", storeALU = ", storeALU);}
 sfg test_ADD { op = 0b000;}
 sfg test_AND { op = 0b001;}
 sfg test_SUB { op = 0b010;}
 sfg test_ADDI { op = 0b011;}
 sfg test_SHIFT_RIGHT_I { op = 0b100;}
 sfg test_LOAD { op = 0b101;}
 sfg test_STORE { op = 0b110;}
 sfg test_JMP { op = 0b111;}
}


fsm f_testbench(testDecoder){
 initial sADD;
 state sAND, sSUB, sADDI, sSHIFT_RIGHT_I, sLOAD, sSTORE, sJMP;
 @sADD (test_ADD) -> sAND;
 @sAND (test_AND) -> sSUB;
 @sSUB (test_SUB) -> sADDI;
 @sADDI (test_ADDI) -> sSHIFT_RIGHT_I;
 @sSHIFT_RIGHT_I (test_SHIFT_RIGHT_I) -> sLOAD;
 @sLOAD (test_LOAD) -> sSTORE;
 @sSTORE (test_STORE) -> sJMP;
 @sJMP (test_JMP) -> sADD;
}
# 3 "CPU/Platform.fdl" 2
# 1 "CPU/memory_fetch.fdl" 1
ipblock instmem(in address : ns(5);
 in wr,rd : ns(1);
 in idata : ns(32);
 out odata : ns(32))
{
 iptype "ram";
 ipparm "size=64";
 ipparm "wl=32";
 ipparm "file=UCI_programs/program.asm";
}

dp PC(in JMP : ns(26);
   in doJMP : ns(1);
   in stall : ns(1);
   out pc_out : ns(32))
{
 reg b : ns(32);
 always{
  b = pc_out;
  pc_out = stall ? b :
     doJMP ? (ns(32))JMP : b + 1;
 }
}


dp fetch(in address : ns(5); out odata : ns(32))
{
 reg idata : ns(32);

 use instmem(address, 0, 1, idata, odata);
}
# 4 "CPU/Platform.fdl" 2
# 1 "CPU/mux_ALU_b.fdl" 1
dp mux_ALU_b(in b : ns(32);
      in intermediate : ns(23);
      in useIntermediate : ns(1);
      out correctB : ns(32)){
 always {
  correctB = useIntermediate ? (ns(32))intermediate : b;
 }
}

dp testMux(out b : ns(32);
       out intermediate : ns(23);
    out useIntermediate : ns(1);
    in correctB : ns(32)){


 always{$display($dec, "Cycle:", $cycle, ". Testing advanced ALU mux for the CPU. b = ", b , ", intermediate = ", intermediate , " useIntermediate = ", useIntermediate, ", correctB = ", correctB);}
 sfg test_UseIntermediate {b = 55; intermediate = 35; useIntermediate = 1;}
 sfg test_UseBGiven {b = 55; intermediate = 35; useIntermediate = 0;}
}


fsm mux_testbench(testMux){
    initial sUseIntermediate;
    state sUseBGiven;
    @sUseIntermediate (test_UseIntermediate) -> sUseBGiven;
    @sUseBGiven (test_UseBGiven) -> sUseIntermediate;
}
# 5 "CPU/Platform.fdl" 2
# 1 "CPU/register.fdl" 1
dp mux8a(in r0, r1, r2, r3,r4, r5, r6, r7 : ns(32);
        in sel : ns(3);
        out res : ns(32))
{
    always
    {
        res = sel[2] ? sel[1] ? sel[0] ? r7 : r6 :
                                 sel[0] ? r5 : r4 :
                        sel[1] ? sel[0] ? r3 : r2 :
                                 sel[0] ? r1 : r0;
    }
}

dp mux8b : mux8a

dp register(in asel, bsel : ns(3);
   in storeenable : ns(1);
   in storesel : ns(3);
   in storedata : ns(32);
   out a, b : ns(32)) {
 reg r0 : ns(32);
 reg r1 : ns(32);
 reg r2 : ns(32);
 reg r3 : ns(32);
 reg r4 : ns(32);
 reg r5 : ns(32);
 reg r6 : ns(32);
 reg r7 : ns(32);




 always {
   a = asel == 0b000 ? r0 :
   asel == 0b001 ? r1 :
   asel == 0b010 ? r2 :
   asel == 0b011 ? r3 :
   asel == 0b100 ? r4 :
   asel == 0b101 ? r5 :
   asel == 0b110 ? r6 :
        r7;

  b = bsel == 0b000 ? r0 :
   bsel == 0b001 ? r1 :
   bsel == 0b010 ? r2 :
   bsel == 0b011 ? r3 :
   bsel == 0b100 ? r4 :
   bsel == 0b101 ? r5 :
   bsel == 0b110 ? r6 :
        r7;

  r1 = storeenable == 0 ? r1 : storesel == 0b001 ? storedata : r1;
  r2 = storeenable == 0 ? r2 : storesel == 0b010 ? storedata : r2;
  r3 = storeenable == 0 ? r3 : storesel == 0b011 ? storedata : r3;
  r4 = storeenable == 0 ? r4 : storesel == 0b100 ? storedata : r4;
  r5 = storeenable == 0 ? r5 : storesel == 0b101 ? storedata : r5;
  r6 = storeenable == 0 ? r6 : storesel == 0b110 ? storedata : r6;
  r7 = storeenable == 0 ? r7 : storesel == 0b111 ? storedata : r7;
 }
}
# 6 "CPU/Platform.fdl" 2
# 1 "CPU/busCMD.fdl" 1
dp busCMD(in target : ns(4);
    in RW : ns(1);
    in address : ns(32);
    out M_CMD : ns(32))
{
 always
 {
  M_CMD = target # RW # address[0:26];
 }
}

dp test(out target : ns(4);
    out RW : ns(1);
    out address : ns(32);
    in M_CMD : ns(32))
{
 always
 {
  target = 0b0100;
  RW = 1;
  address = 0b0101000010000001;
 }
}
# 7 "CPU/Platform.fdl" 2
# 1 "CPU/registerStore.fdl" 1
dp registerStore(in selFromBus : ns(1);
     in fromALU : ns(32);
     in fromBus : ns(32);
     out toRegister : ns(32))
{
 always
 {
  toRegister = selFromBus ? fromBus : fromALU;
 }
}
# 8 "CPU/Platform.fdl" 2
# 1 "CPU/stall.fdl" 1
dp shouldStall(in doBus : ns(1);
      in busDone : ns(1);
      out stall : ns(1))
{
 always
 {
  stall = doBus & (~busDone);
 }
}

dp teststall(out doBus : ns(1);
  out busDone : ns(1);
  in stall : ns(1))
{
 always
 {
  doBus = 1;
  busDone = 0;
  $display($dec, stall);
 }
}
# 9 "CPU/Platform.fdl" 2

$option "vcd"
# 22 "CPU/Platform.fdl"
dp CPU(
           out M_datain : ns(32);
           out M_cmd : ns(32);
           out M_datainrdy : ns(1);
           in M_dataout : ns(32);
           in M_dataoutrdy : ns(1))
{

 use shouldStall(doBus, M_dataoutrdy, stall);
 use PC(odata[0:25], pcJMP, stall, pc_out);
 use fetch(pc_out, odata);

 use decoder(odata[29:31], pcJMP, ALUInstruction, useIntermediate, storeALU, doBus, RW);

 use registerStore(M_dataout, ALUout, M_dataout, toRegister);
 use register(odata[23:25], odata[20:22], storeALU, odata[26:28], toRegister, a, b);
 use mux_ALU_b(b, odata[0:22], useIntermediate, correctB);
 use ALU(a, correctB, ALUInstruction, ALUout);

 use busCMD(odata[0:3], RW, a, M_cmd);

    always
 {
     M_datain = b;
     M_datainrdy = doBus;
 }
}





dp bus(

        in reqCPU : ns(1);
        in cmdCPU : ns(32);
        in dataoutCPU : ns(32);
        out ackCPU : ns(1);

        out dataRdyCPU : ns(1);
        out datainCPU : ns(32);
        in waitCPU : ns(1);


        out reqDataMem : ns(1);
        out cmdDataMem : ns(32);
        out datainDataMem : ns(32);
        in ackDataMem : ns(1);

        in dataRdyDataMem : ns(1);
        in dataoutDataMem : ns(32);
        out waitDataMem : ns(1);


        out reqSensor : ns(1);
        out cmdSensor : ns(32);
        out NotUsed1 : ns(32);
        in ackSensor : ns(1);

        in dataRdySensor : ns(1);
        in dataoutSensor : ns(32);
        out waitSensor : ns(1);


        out reqOutput : ns(1);
        out cmdOutput : ns(32);
        out datainOutput : ns(32);
        in ackOutput : ns(1);

        in dataRdyOutput : ns(1);
        in dataoutOutput : ns(32);
        out waitOutput : ns(1);


        in ID_Sensor : ns(4);
        in ID_DataMem : ns(4);
        in ID_Output : ns(4)

        ){

        $trace(reqDataMem, "traces/reqDataMem.seq");
        $trace(cmdDataMem, "traces/cmdDataMem.seq");
        $trace(datainDataMem, "traces/datainDataMem.seq");
        $trace(ackDataMem, "traces/ackDataMem.seq");
        $trace(dataRdyDataMem, "traces/dataRdyDataMem.seq");
        $trace(dataoutDataMem, "traces/dataoutDataMem.seq");
        $trace(waitDataMem, "traces/waitDataMem.seq");

        $trace(reqSensor, "traces/reqSensor.seq");
        $trace(cmdSensor, "traces/cmdSensor.seq");
        $trace(ackSensor, "traces/ackSensor.seq");
        $trace(dataRdySensor, "traces/dataRdySensor.seq");
        $trace(dataoutSensor, "traces/dataoutSensor.seq");
        $trace(waitSensor, "traces/waitSensor.seq");

        $trace(reqOutput, "traces/reqOutput.seq");
        $trace(cmdOutput, "traces/cmdOutput.seq");
        $trace(datainOutput, "traces/datainOutput.seq");
        $trace(ackOutput, "traces/ackOutput.seq");
        $trace(dataRdyOutput, "traces/dataRdyOutput.seq");
        $trace(dataoutOutput, "traces/dataoutOutput.seq");
        $trace(waitOutput, "traces/waitOutput.seq");

        $trace(reqCPU, "traces/reqCPU.seq");
        $trace(cmdCPU, "traces/cmdCPU.seq");
        $trace(dataoutCPU, "traces/dataoutCPU.seq");
        $trace(ackCPU, "traces/ackCPU.seq");
        $trace(dataRdyCPU, "traces/dataRdyCPU.seq");
        $trace(datainCPU, "traces/datainCPU.seq");
        $trace(waitCPU, "traces/waitCPU.seq");

        always{
          ackCPU = (cmdCPU[28:31] == ID_DataMem & ackDataMem) | (cmdCPU[28:31] == ID_Sensor & ackSensor) | (cmdCPU[28:31] == ID_Output & ackOutput);
          dataRdyCPU = dataRdyDataMem | dataRdySensor | dataRdyOutput;

          reqDataMem = reqCPU;
          cmdDataMem = (reqCPU) ? cmdCPU : 0;
          datainDataMem = (reqCPU) ? dataoutCPU : 0;

          reqSensor = reqCPU;
          cmdSensor = (reqCPU) ? cmdCPU : 0;
          waitSensor = waitCPU;

          reqOutput = reqCPU;
          cmdOutput = (reqCPU) ? cmdCPU : 0;
          datainOutput = (reqCPU) ? dataoutCPU : 0;
          waitOutput = waitCPU;

          datainCPU = (dataRdyDataMem) ? dataoutDataMem :
                      (dataRdySensor) ? dataoutSensor :
                      (dataRdyOutput) ? dataoutOutput :
                      0;
          waitDataMem = waitCPU;

          NotUsed1 = 0;
        }
}

dp slavebusinterface(

          in bus_req : ns(1);
          in bus_cmd : ns(32);
          in bus_datain : ns(32);
          out bus_ack : ns(1);

          out bus_rdy : ns(1);
          out bus_dataout : ns(32);
          in bus_wait : ns(1);


          in datain : ns(32);
          in datainrdy : ns(1);
          out dataout : ns(32);
          out cmdout : ns(32);
          out dataoutrdy : ns(1);
          in targetID : ns(4);
          out stallSlave : ns(1)
          ){

          reg bus_reqr : ns(1);
          reg bus_waitr : ns(1);
          reg datainrdyr : ns(1);
          reg targetIDr : ns(4);
          reg bus_cmdr : ns(32);

          always{
             bus_reqr = bus_req;
             bus_waitr = bus_wait;
             datainrdyr = datainrdy;
             targetIDr = targetID;
             bus_cmdr = bus_cmd;
          }

          sfg externalData{
             bus_ack = 1;
             dataout = bus_datain;
             cmdout = bus_cmd;
             dataoutrdy = bus_cmd[28:31] == targetID;

             bus_rdy = 0;
             bus_dataout = 0;
             stallSlave = 1;
          }

          sfg ackExternalData{
             bus_ack = 0;
             dataout = 0;
             cmdout = 0;
             dataoutrdy = 0;
             bus_rdy = 0;
             bus_dataout = 0;
             stallSlave = 1;
          }

          sfg internalData{
             bus_dataout = datain;
             bus_rdy = 1;

             bus_ack = 0;
             dataout = 0;
             cmdout = 0;
             dataoutrdy = 0;
             stallSlave = 1;
          }

          sfg ackInternalData{
             bus_rdy = 0;
             bus_dataout = 0;

             bus_ack = 0;
             dataout = 0;
             cmdout = 0;
             dataoutrdy = 0;
             stallSlave = 1;
          }

          sfg nothing{
             bus_ack = 0;
             dataout = 0;
             cmdout = 0;
             dataoutrdy = 0;
             bus_rdy = 0;
             bus_dataout = 0;
             stallSlave = 0;
          }

}

fsm slavebusinterface_cntrl(slavebusinterface){
   initial s0;
   state s1,s2,s3;


   @s0 if (bus_reqr == 1 & bus_cmdr[28:31] == targetIDr) then (externalData) -> s1;
       else (nothing) -> s0;
   @s1 if (bus_reqr == 0) then (ackExternalData) ->s2;
       else (externalData) -> s1;
   @s2 if (datainrdyr == 1) then (internalData) -> s3;
       else (nothing) -> s2;
   @s3 if (bus_waitr == 1) then (ackInternalData) -> s0;
       else (internalData) -> s3;

}

dp slavebusinterface2 : slavebusinterface
dp slavebusinterface3 : slavebusinterface

dp masterbusinterface(

          out bus_req : ns(1);
          out bus_cmd : ns(32);
          out bus_dataout : ns(32);
          in bus_ack : ns(1);

          in bus_rdy : ns(1);
          in bus_datain : ns(32);
          out bus_wait : ns(1);


          in datain : ns(32);
          in cmd : ns(32);
          in datainrdy : ns(1);
          out dataout : ns(32);
          out dataoutrdy : ns(1)
          ){
# 302 "CPU/Platform.fdl"
          reg bus_ackr : ns(1);
          reg bus_rdyr : ns(1);
          reg datainrdyr : ns(1);
          reg cmdr : ns(32);
          reg datainr : ns(32);

          always{
             bus_ackr = bus_ack;
             bus_rdyr = bus_rdy;
             datainrdyr = datainrdy;
             cmdr = cmd;
             datainr = datain;
          }

          sfg internalData{
             bus_req = 1;
             bus_cmd = cmd;
             bus_dataout = datain;

             bus_wait = 0;
             dataout = 0;
             dataoutrdy = 0;
          }

          sfg ackInternalData{
             bus_req = 0;
             bus_cmd = cmdr;
             bus_dataout = datainr;

             bus_wait = 0;
             dataout = 0;
             dataoutrdy = 0;
          }

          sfg externalData{
             bus_wait = 1;
             dataout = bus_datain;
             dataoutrdy = 1;

             bus_req = 0;
             bus_cmd = 0;
             bus_dataout = 0;
          }

          sfg ackExternalData{
              bus_wait = 0;
              dataout = 0;
              dataoutrdy = 0;

              bus_req = 0;
              bus_cmd = 0;
              bus_dataout = 0;
          }

          sfg nothing{
             bus_req = 0;
             bus_cmd = cmdr;
             bus_dataout = datainr;

             bus_wait = 0;
             dataout = 0;
             dataoutrdy = 0;
          }
}

fsm masterbusinterface_cntrl(masterbusinterface){
   initial s0;
   state s1,s2,s3,s4;

   @s0 if (datainrdyr == 1) then (internalData) -> s1;
       else (nothing) -> s0;
   @s1 if (bus_ackr == 1) then (ackInternalData) -> s3;
       else (internalData) -> s1;
   @s3 if (bus_rdyr == 1) then (externalData) -> s2;
       else (nothing) -> s3;
   @s2 (ackExternalData) -> s4;
   @s4 (nothing) -> s0;
}

dp bus_toplevel(

           in M_datain : ns(32);
           in M_cmd : ns(32);
           in M_datainrdy : ns(1);
           out M_dataout : ns(32);
           out M_dataoutrdy : ns(1);



           in DM_datain : ns(32);
           in DM_datainrdy : ns(1);
           out DM_dataout : ns(32);
           out DM_cmdout : ns(32);
           out DM_dataoutrdy : ns(1);
           out DM_stall : ns(1);


           in SS_datain : ns(32);
           in SS_datainrdy : ns(1);
           out SS_dataout : ns(32);
           out SS_cmdout : ns(32);
           out SS_dataoutrdy : ns(1);
           out SS_stall : ns(1);


           in OP_datain : ns(32);
           in OP_datainrdy : ns(1);
           out OP_dataout : ns(32);
           out OP_cmdout : ns(32);
           out OP_dataoutrdy : ns(1);
           out OP_stall : ns(1)
           ){

           sig reqCPU,reqDataMem,reqSensor,reqOutput,ackCPU,ackDataMem,ackSensor,ackOutput,dataRdyCPU,dataRdyDataMem,dataRdySensor,dataRdyOutput,waitCPU,waitDataMem,waitSensor,waitOutput: ns(1);
           sig cmdCPU,cmdDataMem,cmdSensor,cmdOutput,dataoutCPU,datainDataMem,datainSensor,datainOutput,datainCPU,dataoutDataMem,dataoutSensor,dataoutOutput : ns(32);
           reg ID_DataMem : ns(4);
           reg ID_Sensor : ns(4);
           reg ID_Output : ns(4);

           $trace(DM_datain, "traces/DM_datain.seq");
           $trace(DM_datainrdy, "traces/DM_datainrdy.seq");
           $trace(DM_dataout, "traces/DM_dataout.seq");
           $trace(DM_cmdout, "traces/DM_cmdout.seq");
           $trace(DM_dataoutrdy, "traces/DM_dataoutrdy.seq");

           $trace(SS_datain, "traces/SS_datain.seq");
           $trace(SS_datainrdy, "traces/SS_datainrdy.seq");
           $trace(SS_dataout, "traces/SS_dataout.seq");
           $trace(SS_cmdout, "traces/SS_cmdout.seq");
           $trace(SS_dataoutrdy, "traces/SS_dataoutrdy.seq");

           $trace(OP_datain, "traces/OP_datain.seq");
           $trace(OP_datainrdy, "traces/OP_datainrdy.seq");
           $trace(OP_dataout, "traces/OP_dataout.seq");
           $trace(OP_cmdout, "traces/OP_cmdout.seq");
           $trace(OP_dataoutrdy, "traces/OP_dataoutrdy.seq");

           use bus(reqCPU,cmdCPU,dataoutCPU,ackCPU,dataRdyCPU,datainCPU,waitCPU,
                   reqDataMem,cmdDataMem,datainDataMem,ackDataMem,dataRdyDataMem,dataoutDataMem,waitDataMem,
                   reqSensor,cmdSensor,datainSensor,ackSensor,dataRdySensor,dataoutSensor,waitSensor,
                   reqOutput,cmdOutput,datainOutput,ackOutput,dataRdyOutput,dataoutOutput,waitOutput,
                   ID_Sensor,ID_DataMem,ID_Output);

           use masterbusinterface(reqCPU,cmdCPU,dataoutCPU,ackCPU,dataRdyCPU,datainCPU,waitCPU,

                                  M_datain,M_cmd,M_datainrdy,M_dataout,M_dataoutrdy);

           use slavebusinterface(reqDataMem,cmdDataMem,datainDataMem,ackDataMem,dataRdyDataMem,dataoutDataMem,waitDataMem,

                             DM_datain,DM_datainrdy,DM_dataout,DM_cmdout,DM_dataoutrdy,ID_DataMem,DM_stall);

           use slavebusinterface2(reqSensor,cmdSensor,datainSensor,ackSensor,dataRdySensor,dataoutSensor,waitSensor,

                              SS_datain,SS_datainrdy,SS_dataout,SS_cmdout,SS_dataoutrdy,ID_Sensor,SS_stall);

           use slavebusinterface3(reqOutput,cmdOutput,datainOutput,ackOutput,dataRdyOutput,dataoutOutput,waitOutput,

                              OP_datain,OP_datainrdy,OP_dataout,OP_cmdout,OP_dataoutrdy,ID_Output,OP_stall);

           always{
              ID_Sensor = 0x1;
              ID_DataMem = 0x2;
              ID_Output = 0x3;
           }
}




ipblock datamem(in address : ns(12);
          in wr,rd : ns(1);
          in idata : ns(32);
          out odata : ns(32)){

  iptype "ram";
  ipparm "size=4096";
  ipparm "wl=32";
  ipparm "file=datamemory.asm";

}

dp DataMem(
   in datain : ns(32);
   in cmd : ns(32);
   in datainrdy : ns(1);
   out dataout : ns(32);
   out dataoutrdy : ns(1);
   in stall : ns(1)
   ){

   sig wr,rd : ns(1);
   sig address : ns(12);
   sig idata : ns(32);

   reg datainrdyr : ns(1);
   reg cmdr : ns(32);
   reg datainr : ns(32);
   reg dataoutr : ns(32);
   reg stallr : ns(1);

   use datamem(address,wr,rd,idata,dataout);

   $trace(address, "traces/DM_address.seq");
   $trace(wr, "traces/DM_wr.seq");
   $trace(rd, "traces/DM_rd.seq");
   $trace(idata, "traces/DM_idata.seq");

   always{
       stallr = stall;
       rd = cmdr[27] == 0;
       wr = cmdr[27] == 1;
       address = (cmdr[27] == 0) ? datainr : 0b00000 # cmdr[0:26];
       idata = (cmdr[27] == 0) ? 0 : datainr;


   }

   sfg captureData{
       dataoutrdy = 0;
       datainrdyr = datainrdy;
       datainr = datain;
       cmdr = cmd;
   }

   sfg awaithandshake{
      dataoutrdy = 0;
   }

   sfg resetAndSignalRdy{
     dataoutrdy = 1;
     datainrdyr = 0;
   }

   sfg nothing{
       dataoutrdy = 0;
   }

}

fsm DataMem_cntrl(DataMem){
   initial s0;
   state s1;

   @s0 if (datainrdyr == 1 & stallr == 0) then (resetAndSignalRdy) -> s0;
       else if (datainrdyr == 1 & stallr == 1) then (nothing) -> s1;
       else (captureData) -> s0;
   @s1 if (stallr == 0) then (resetAndSignalRdy) -> s0;
       else (awaithandshake) -> s1;

}

ipblock sensordata(in address : ns(5);
          in wr,rd : ns(1);
          in idata : ns(32);
          out odata : ns(32)){

  iptype "ram";
  ipparm "size=32";
  ipparm "wl=32";
  ipparm "file=sddb48hex.ecg";

}

dp Sensor(
   in datain : ns(32);
   in cmd : ns(32);
   in datainrdy : ns(1);
   out dataout : ns(32);
   out dataoutrdy : ns(1);
   in stall : ns(1)
   ){

    sig address : ns(5);
    sig wr,rd : ns(1);
    sig idata,odata : ns(32);

    use sensordata(address,wr,rd,idata,odata);

    reg c : ns(10);
    reg reset : ns(1);
    reg addr : ns(8);
    reg LIMIT : ns(10);
    reg stallr : ns(1);
    reg datainrdyr : ns(1);

    $trace(odata, "traces/SS_data.seq");
    $trace(c, "traces/SS_c.seq");

    always{
     wr = 0;
     idata = 0;
     LIMIT = 9;
     address = addr;

     dataout = odata;

     stallr = stall;



    }

   sfg captureData{
       dataoutrdy = 0;
       datainrdyr = datainrdy;

   }

   sfg awaithandshake{
      dataoutrdy = 0;
   }

   sfg resetAndSignalRdy{
     dataoutrdy = 1;
     datainrdyr = 0;
   }

   sfg nothing{
       dataoutrdy = 0;
   }

 sfg count{
     c = c + 1;
     rd = 0;
 }

    sfg addressUpdate{
       addr = addr + 1;
       rd = 1;
       c = 0;
    }

}

fsm sensor_cntrl(Sensor){
   initial s0;
   state s1;

   @s0 if (datainrdyr == 1 & stallr == 0 & c == LIMIT) then (addressUpdate,resetAndSignalRdy) -> s0;
       else if (datainrdyr == 1 & stallr == 0 & c != LIMIT) then (count,resetAndSignalRdy) -> s0;
       else if (datainrdyr == 1 & stallr == 1 & c == LIMIT) then (addressUpdate,nothing) -> s1;
       else if (datainrdyr == 1 & stallr == 1 & c != LIMIT) then (count,nothing) -> s1;
       else if (datainrdyr == 0 & c == LIMIT) then (addressUpdate,captureData) -> s0;
       else (count,captureData) -> s0;
   @s1 if (stallr == 0 & c == LIMIT) then (addressUpdate,resetAndSignalRdy) -> s0;
       else if (stallr == 0 & c != LIMIT) then (count,resetAndSignalRdy) -> s0;
       else if (stallr == 1 & c == LIMIT) then (addressUpdate,awaithandshake) -> s1;
       else (count,awaithandshake) -> s1;
}

dp Output(
   in datain : ns(32);
   in cmd : ns(32);
   in datainrdy : ns(1);
   out dataout : ns(32);
   out dataoutrdy : ns(1);
   in stall : ns(1);
   out FilterOut : tc(32)
   ){

   reg datainrdyr : ns(1);
   reg cmdr : ns(32);
   reg datainr : ns(32);
   reg dataoutr : ns(32);
   reg stallr : ns(1);
   reg count : ns(10);
   reg FilterOut_r : tc(32);

   $trace(FilterOut, "traces/FilterOut.seq");
   $trace(count, "traces/out_count.seq");

   always{
       stallr = stall;
       dataout = 0x123;
   }

   sfg captureData{
       dataoutrdy = 0;
       datainrdyr = datainrdy;
       datainr = datain;
       cmdr = cmd;

       FilterOut = FilterOut_r;
   }

   sfg awaithandshake{
      dataoutrdy = 0;

      FilterOut = FilterOut_r;
   }

   sfg resetAndSignalRdy{
     dataoutrdy = 1;
     datainrdyr = 0;
   }

   sfg nothing{
       dataoutrdy = 0;

       FilterOut = FilterOut_r;
   }

   sfg setFilterOut{
      FilterOut = datainr;
      FilterOut_r = datainr;
      count = count + 1;
   }

}

fsm Output_cntrl(Output){
   initial s0;
   state s1;

   @s0 if (datainrdyr == 1 & stallr == 0) then (resetAndSignalRdy,setFilterOut) -> s0;
       else if (datainrdyr == 1 & stallr == 1) then (nothing) -> s1;
       else (captureData) -> s0;
   @s1 if (stallr == 0) then (resetAndSignalRdy,setFilterOut) -> s0;
       else (awaithandshake) -> s1;

}




system CPUsystem{

   CPU(CPUdatain,CPUcmd,CPUdatainrdy,CPUdataout,CPUdataoutrdy);

   bus_toplevel(CPUdatain,CPUcmd,CPUdatainrdy,CPUdataout,CPUdataoutrdy,
           DMDatain,DMDatainrdy,DMDataout,DMCmdout,DMDataoutrdy,DMStall,
           SensorDatain,SensorDatainrdy,SensorDataout,SensorCmdout,SensorDataoutrdy,SensorStall,
           OPDatain,OPDatainrdy,OPDataout,OPCmdout,OPDataoutrdy,OPStall);

   DataMem(DMDataout,DMCmdout,DMDataoutrdy,DMDatain,DMDatainrdy,DMStall);
   Sensor(SensorDataout,SensorCmdout,SensorDataoutrdy,SensorDatain,SensorDatainrdy,SensorStall);
   Output(OPDataout,OPCmdout,OPDataoutrdy,OPDatain,OPDatainrdy,OPStall,FilterOut);
}
